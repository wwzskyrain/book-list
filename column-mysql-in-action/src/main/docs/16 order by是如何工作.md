# 1.基本内容
1.  两个排序策略：全字段排序、rowId排序
2.  explain中extra字段的意思
3.  慢查询

# 2.详细介绍
1.  全字段索引：
    1.  排序语句：select city, name, age from c where city = 'hang_zhou' limit 1000;
    2.  定义：把所有的要查询的字段放到sort_buffer中一起排序。当然，要参与排序的数据能放得下sort_buffer。
    3.  如果放不下呢，是要用临时表吗，还是用row_id排序？
    4.  可以用一个方法来查看是否使用了临时表：查看 OPTIMIZER_TRACE 的结果来确认，具体见附录A
    5.  临时表排序是什么算法，归并排序（可不是堆排序呀），一定是非内存吗？
    6.  归并排序使用到的临时文件个数是受到sort_buffer和要排序的数量公共限制的，
        因为每个归并排序的文件都是基于sort_buffer的内存的局部排序产生的
    7.  如果要参与排序的字段太多，那么sort_buffer中一次能放的行数就少了，产生的临时文件也就多了，不能这样。
        这时候就不要用全字段排序了，用row_id排序

2.  row_id排序：
    1.  定义：就是把权值字段和row_id放到sort_buffer进行排序就好了，排好之后，再用row_id去回表
    2.  字段多少算是字段太多呢?或者说，行数据多大才算是大行呢？有配置项：max_length_for_sort_data
    3.  row_id排序就不在使用临时表了吗？
        不是的，一样会用，但是临时表的个数就变少了；归并排序的算法是堆排序，这样堆就小了很多，再堆调整时就快了一些
        
3.  全字段排序 vs row_id排序
    1.  差别就是，row_id排序多了回表，而全字段排序少了回表；
    2.  mysql的策略是，优先使用全字段排序：尽量减少io操作，尽量内存操作。
        啥内存操作？归并排序也是内存操作？是的，临时表也有可能是内存临时表。

4.  更有趣的：并不是所有的order by语句都需要排序操作，甚至都不需要把所有符合条件的数据都查出来；所以，聪明的你，也猜到了吧，
        因为这时候数据已经有序了。哦，明白，联合索引
    1.  extra中少了，Using filesort 了，也就是不需要排序了
    2.  比如：select name，city，age from c where c = '杭州' order by name limit 1000
        而且有联合索引 ix_city_name
    3.  那就不需要排序了，因为在杭州的大索引下，name是有序的；直接选前1000行，回表查然后就返回吧；注意：
        1.  是查一条，回表一条，返回client一条，不是批量来搞的哈
        2.  如果语句是desc降序呢，这就和索引的升序相反了，还能走索引吗？

5.  思考题：
    1.  如果'select name, city, age from c where c in ('杭州', '苏州') order by name limit 100'
        就断然用不上了ix_city_name索引了。这时候如何优化呢？
    2.  从业务方开始优化
        1.  去杭州的前100条
        2.  取苏州的前100条
        3.  业务方在这200条中排序找到前100条。
    3.  经验：不要在sql层面做业务逻辑，db最好就是用来读写数据而已。
     
    


# 思考：
1.  如果排序语句是'select name，city，age from c where c = '杭州' order by name desc limit 1000'
    能否用到ix_city_name索引呢？

# 附录
