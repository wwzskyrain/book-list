# 1.基本内容
1.  mysql如何利用另个日志来保证数据安全的？


# 2.具体内容
1.  wal机制是两步的，1-写redo-log，2-写binlog
    其实这里的两步是逻辑上说的，真实情况是
    1.写redo-log到cache
    2.写binlog到cache
    3.把redo-log刷新到disk
    4.把binlog刷到disk
    5.总结：整体上还是上面的12两步，但是12两步是都要落到disk的，
        不然就丢失了log数据，就没办法实现crash-safe了。
        如何保证两个log的完整性，请看23章-mysql保证数据不丢失的秘密。
2.  假设保证了redo-log和binlog的完整，在异常重启机器时，crash-safe如何做的呢？
    1.redo-log中的事务是完整提交了的，
        那就--把相应数据页读到内存然后应用该log中的事务，这时该数据页就变成脏页(其实是最新的页)了。
    2.redo-log发现事务是prepare阶段：
        1.binlog中该事务是完整的，则提交
        2.binlog中该事务是不完整的，则回滚事务；具体如何回滚呢？我的思考

3.  mysql如何判断binlog是完整的
    1.statement格式的binlog，最后会有commit的
    2.row格式的binlog，最后有XID event
    3.binlog本身也有checksum

4.  redo-log和binlog是如何对应的？
    1.XID字段，redo-log和binlog共有

5.  为什么在异常重启时，要检查到binlog完整，就要试图提交？
    1.因为从库有可能已经应用了这个binlog，即保持主备一致

6.  为什么要两阶段提交
    1.两阶段提交是分布式一致性的一个解决方案，非mysql特有
    2.本质是给每一个参与者一个机会，然后大家一块提交(其实，mysql这里只要redo-log提交)
    3.我思：其实当明白要面对的问题是分布式一致性时，我们就可以知道，一定要大家一块提交才好。
        在著名的2PC场景中，是需要有一个协调者的，但是那里不对参与者个数做限制；
        mysql中就两个参与者，所以完全可以不用协调者

7.  只保留一个binlog能否做崩溃恢复？
    1.不能，因为binlog中记录的不是数据页的内容，而是语句或者行。
        当崩溃时，脏页丢失了；要恢复这些脏页，就要再次应用binlog(用redo-log时也是这样干的)
        到对应的数据页上；但是不能确定一条语句是否应该被应用，比如这一条binlog日志对应的
        脏页在奔溃之前被刷到的disk从而变成了干净的页面，但是binlog中就没有数据也的版本这类东西，
        从而不知道对应的数据页是不是最新的，从而说binlog没有数据页恢复的能力；
        所以，binlog不能做崩溃恢复。

8.  只用redo-log，可以吗？
    1.redo-log也不能把所有的活都干了，比如binlog提供的归档的功能，redo-log就干不了。
        因为redo-log文件的大小受限，一般也就4G(磁盘空间哟)
    2.再说，binlog有生态呢

9.  mysql语句的写操作最终是如何落盘的？
    1.首先，不是从redo-log刷进去的
    2.其次是从脏页刷到disk的
    3.再崩溃恢复时，如果判断了某个页面丢失了数据，就把这个页面读到内存然后应用redo-log。

10. 一个like到friend的实践问题
    1.  用唯一索引和`insert ... on duplicate key update`语句 
    2.  把A、B按照大小排序
    3.  文中巧妙的使用了1，2点，同时增加`relation`字段，分别表示A喜欢B，B喜欢A，AB相互喜欢
    4.  个人观点：不要用这种奇技淫巧，不要在mysql语句中夹杂业务逻辑，业务逻辑就写在代码里就行了。
    5.  那现在怎么办呢？简单呀，用常用的`读-逻辑判断-写`+乐观锁+重试呀(这里不是不用relation字段)
        只是不想用`on duplicate key update`这种形式
    

11. 最后，数据如何刷盘，即redo-log和binlog的写入机制，快去看23章
