# 1.基本内容
1.  继续explain分析sql
2.  如何查看mysql的慢日志
3.  通过介绍order by rand() limit 3的执行流程，来说明它不可用；然后又给出了三个可行的方案


# 2.详细内容
1.  对于查询语句 `select word from word_table order by rand() limit 3`
2.  explain结果：extra字段中，有using temporary，表示使用临时表；有using filesort，表示
    需要排序操作——sort_buffer(还有不需要排序操作的？对呀，联合索引，忘啦？甚至还有不需要回表的呢)
3.  而且是内存临时表；对于内存临时表，那么回表就不是io操作了，所以排序策略就偏向于'row_id排序了'
4.  执行流程：
    1.  创建临时表——memory引擎(大数组)
    2.  依次取出word_table中的所有word值，（不放入临时表），并给每个word生成一个随机数(0-1范围)，
        然后把word和这个随机值放到临时表。（最终还是放到临时表了，因为要用临时表做底表来被回表的呀）
    3.  这时候已经扫描10000行(word_table中所有的行数)
    4.  开辟sort_buffer，从临时表中取出随机值和其对应的位置信息(就是下标，注意这里不是row_id)。
        需要对临时表做全表扫描；扫面行数增加10000，变成了20000.
    5.  在sort_buffer中排序吧；用什么排序算法呢？排序过程不设计扫描行
    6.  排序完，取出前三个，并取出对应的在内存表中的word字段返回；扫描行数加3(当然是数组的随机访问了)
    7.  小结：order by rand() 使用了内存临时表，内存临时表排序的时候使用了row_id排序算法——因为
        回表不是件难事。

5.  所有的临时表都是内存临时表吗？no，有配置的，tmp_table_size就是内存临时表的大小，超了就磁盘临时表
6.  把内存临时表的限制变小，让排序使用内存临时表；把sort_buffer也变小，让排序在sort_buffer中装不下，
    那么上面那个语句应会用临时文件吗？（临时文件、临时表是不同的东西，详见7）
    不一定，还是可以能不用临时文件的，而是用堆排序。
    堆排序有个好处，可以一次遍历，然后最后留在堆中的就是要找的最小(大)的几个值。
    但是这种玩法，只能是limit 100， 而不能是limit 100，10，即limit不能有base参数，
    这叫做'优先级队列'。
    那么limit 100000，也会用这个方法，而避免用归并排序吗？
    其实也不一定，只要sort_buffer足够一个10000个节点的小(大)顶堆就好了。

7.  什么时候用临时文件(归并排序时)，什么时候用临时表？
    1.  首先这是两个不同的概念
    2.  临时文件是需要归并排序时，总结一句就是sort_buffer不够排序空间了，就会用临时文件进行归并排序。
    3.  临时表呢？临时表是底表的一个替代品，或者说一个局部view(有时甚至做了一点变形)。不行，对这个词，越写越觉得不了解它，得查一查，搞清楚
        丁老师说，在查询时用临时表。比如在rand()的时候，就对底表进行了rand()处理之后保存了到了临时表中。

8.  好了，上面都是在show，真实情况谁也不会用rand()来取随机值，业务一般这样做：
    1.  方案一：找主键的max和min，在业务方取二者中的一个随机值r，然后去floor(r)。缺点，主键分布不均时，不够随机
    2.  方案二：取行数C，然后rand(C) = r, 然后limit r,1。优点：不在不随机；缺点：扫面行数明显比方案一大多了。但是还是比mysql的rand()好很多。why?
    3.  方案三：没有方案三。

# 思考：
1.  什么时候用临时文件(归并排序时)，什么时候用临时表？
2.  mysql中对临时表的使用是其内部的事情，其实也没有使用场景吧。
    不，应该还是有的，比如join一节中就有用临时表的例子，快去看看。
3.  方案二那么多扫描行数，为啥还说比mysql的rand还好呢。
    答：方案二的limit是在主键上进行的，主键是有序的，所以limit很快的；比order by rand()方法中
    先组织临时表，再获取row_id代价小很多的。（一个是有序扫描，一个是全局排列）

       