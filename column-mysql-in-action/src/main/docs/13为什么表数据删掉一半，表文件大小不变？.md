
# 1.导读
1.  这里会涉及到mysql-innodb中数据的存储，已经存储空间的利用和回收。
2.  还讲到对数据表压缩的情况。

# 2.删除行记录为啥表空间没变化
1.  开关innodb_file_per_table = on(default)
    表示每个表有自己独立的文件(os层面的)；off的话，表文件就放到系统共享空间，也就是跟数据字典放在一起了。
2.  可复用记录：删除的记录，插入记录，update记录，都可能产生'记录空洞'，也就是可复用记录空间；复用与可复用记录的前后记录的空间内。
3.  可复用page：删除了该page上的所有记录；全局可复用
4.  可复用记录和可复用page都是可复用空间，和jvm的垃圾回收算法中，标记删除很像；
5.  如果紧凑化整体空间：
    1.  【名词解释】紧凑化，而不是完全紧凑化，留有一定的可复用/可使用空间，供update使用。这一点也是mysql在
        重整数据页时也就是紧凑化时采用的策略——按90%满的比例来整理。这一点也会在对一个本来就一定大于90%满
        的数据表进行页重整理后导致表空间反而变大，很显然，这里表空间的整理不是紧凑化，而是稀疏化了。
    2.  【how to do】重建表，使用 `alter table target_table_name engine =
        innodb` 来重新创建表。
    3.  创建表的执行过程：
        1.  创建一个和原表A一样结构的临时表B和一个重建表log
        2.  把A表的数据，按照递增主键顺序一条条插入的B。
        3.  第2步插入过程中，对A表的DML，都记录的重建表log中。
        4.  把log中的DML重新在B中执行
        5.  交换表A和表B的名字
        6.  删除表B(原来的表A)。over
        7.  注意：4，5两个步骤是要锁住表，不能写的(理论上是可以读)
    4.  重建表有`inplace`和`copy`两种模式，上述描述的是inplace的过程。copy模式时，是没有log的，
        并且在复制的过程都是要阻塞DML写操作的。
    5.  inplace和online什么关系呢？online一定是inplace，而反过来不成立，有例子：
        1.  online是指没有阻塞DML，或者阻塞的很短
        2.  ex1：添加全文索引
        3.  ex2：添加空间索引
6.  扩展：
    1.  `alter table`：recreate表，就是我们说的inplace模式。
    2.  `analyze table`：重见表索引的统计信息，不修改数据，加DML读锁
    3.  `optimize table`：是recreate+analyze

7.  课后问题：对一个1T的表进行 recreate之后，发现表空间还稍微变大了，怎么回事？
    1.  回答：就是超过了90%满之后的重建表不是紧凑化表，而是稀疏化表(到90%满)