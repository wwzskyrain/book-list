# 1.导读
1.  mysql中有很多id，比如表自增id，row_id，事务id，Xid等，他们扮演者重要的功能，
    所以，他们的边界是很值得研究的。
2.  本文就对这四个id用完之后的情况做总结。

# 2.自增id用完
1.  每一个表最多只有一个自增id，正常情况下是一个32位的正整数；
2.  最大值是2^32 - 1；之后就一直是这个值保持不变，导致在插入数据报主键冲突。
3.  解决：搞一个无符号的64位的类型做主键自增

# 3.row_id用完了
1.  如果不显示指定主键，则mysql就用row_id作为主键了
2.  row_id是long型但是只用了48位，最大值2^48 -1 
3.  最大值之后，就从0开始；这样新插入的数据就会覆盖row_id=0的数据-->数据就不可靠了，很危险
4.  小结：比较自增id用完和row_id用完的后果，前者呢是可用性受损，后者是可靠性受损，相较之下还是要可靠性吧。

# 4.Xid用完了
1.  Xid是server层的查询id，global_query_id内存变量的瞬时值，每次查询时会记录到binlog中。
2.  Xid是64位，不持久化
3.  每次重启mysql-server，global_query_id都从0开始，同时binlog也是新的，所以，重启不会导致binlog
    中出现相同的Xid；但是理论上在很长的一个mysql_server运行周期内还是有可能耗尽Xid的。
4.  耗尽时，还自增吗？如果自增，那不就是从0开始了？

# 5.事务Id用完了
1.  trx_id是innodb中的概念，每个写事务都有一个唯一的trx_id；
2.  trx_id用在MVCC中实现不同的隔离级别
3.  trx_id是long型但是也只用了48位，到了最大值后，从0再开始；从0开始的时候，就引起脏读了。


# 6. 总结
这几个id的耗尽情况还是很常见的。其导致的结果，只要顺着他们的使用场景思考，就不能想到。