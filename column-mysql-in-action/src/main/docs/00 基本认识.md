# 1.常用命令

# 2.特殊记忆
## 2.1  当前读和一致性读
1.  sql1：select * from table where condition for update. //当前读
2.  在rr级别下，普通的查询是'快照读'，是不会看到别的事务插入的数据的，这就是rr的语义。
    但是，此时如果是'当前读'，那么是会看到别的事务插入的数据的。
3.  哪些是'当前读'呢，如sql1；再如update语句，虽然是写数据，但是还是
4.  当前读的规则，就是要能读到所有已经提交的记录的最新值
5.  一致性：（新解读）不但要数据状态一致，数据和日志的逻辑也要一直
6.  sql2：select * from table where c = 7 lock in share mode.
    这是一致性读。那么它加锁吗？
    
7.  行锁是加在哪里？主键索引上吗？
8.  远离间隙锁，使用RC吧，为了保持'数据与log'的一致性，binlog用row的模式，不要用statement模式了。
9.  隔离级别是db维度？表维度？所有会话？session维度？
10. 如果是session维度，那么sessionA和sessionB一个rc一个rr会有影响吗？
11. 隔离级别不同会影响加锁规则吗？
12. 然后，在备份期间，备份线程用的是可重复读，而业务线程用的是读提交。同时存在两种事务隔离级别，会不会有问题？
13. 进一步地，这两个不同的隔离级别现象有什么不一样的，关于我们的业务，“用读提交就够了”这个结论是怎么得到的？
14. 不同的隔离级别是对应不同的加锁规则吗？
    1.  因为间隙锁在可重复读隔离级别下才有效，所以本篇文章接下来的描述，若没有特殊说明，默认是可重复读隔离级别。
    2.  
15. rr隔离级别下，是两阶段锁，所有的加锁资源，都是在事务提交或者回滚的时候才成的。
16. 在读提交隔离级别下还有一个优化，即：语句执行过程中加上的行锁，在语句执行完成后，就要把“不满足条件的行”上的行锁直接释放了，不需要等到事务提交
    所以，在rc时，既不支持gap锁，就是把上面的加锁过程中把gap锁去掉；然后还会在语句执行完之后，就把不满足的行的行锁删除了。
    读提交隔离级别下，锁的范围更小，锁的时间更短，这也是不少业务都默认使用读提交隔离级别的原因。