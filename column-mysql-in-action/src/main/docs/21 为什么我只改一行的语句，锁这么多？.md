# 1.导读
1.  这是最棒的一篇文章，或者说，是最补的一篇文章。

# 2.加锁规则
1.  意义：有了加锁规则，就可以在不同语句，比如select、update、delete；
    不同的方式，比如limit、order by等情况下分析加锁。

2.  内容：丁老师自己总结的：两个原则，两个优化，一个bug
    1.  原则一：基本单位是next-key lock，一个前开后闭区间
    2.  原则二：访问到的对象才加锁
    3.  优化一：索引上等值查询，唯一索引时，精准化为行锁
    4.  优化二：索引上等值查询，向右遍历到第一个不满足等值条件时， 最后一个 next-key
        lock 精准化为gap lock。
    5.  一个bug：唯一索引上，范围查询会遍历到第一个不满足条件的行为止，并且加上next-key
        lock。比如，唯一索引上
        d<=15，则要扫描到d=20(假设d=20是d=15的下一行)，并且加上(15,20]的next-key锁

3.  几点重要的补充：
    1.  琐是加载索引上的；
    2.  lock in share mode 会对被覆盖索引优化后，不再去加主键索引上加锁； 如果是
        for update，或者select中的列不都在覆盖索引上，则需要到主键索引上扫描并加锁。
    3.  【重要】以上是rr隔离级别上的加锁规则；rc级别是不同的
    4.  rc级别的加锁规则：这还是一个不明确的总结
        1.  去掉gap锁，只加行锁
        2.  非两阶段锁：在语句执行完之后，扫描过的不需要的行锁就释放了
        3.  


4.  一下集中特殊情况下如何加锁
    1. 带limit时，如何影响加锁？ 
    2. 通过扫描行数来影响加锁范围
    3.  order by时，如何影响加锁？
    4.  order by desc时，扫描顺序会从上往下，从而影响加锁

5.  总结：
    1.  不同的session的隔离级别，有什么不同
    2.  
        
    