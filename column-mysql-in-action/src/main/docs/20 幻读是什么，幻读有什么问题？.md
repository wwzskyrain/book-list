# 1.导读
# 2.笔记
1.  幻读是在前后两个同样的当前读时，返回其他事务插入的新行，如果不是新行，则不叫幻读
2.  幻读说明
    1.  可重复读隔离级别：普通读都是快照读，是不会看到别的事务插入的数据的，
        即幻读只在'当前读'下出现。
    2.  当前读？加上 'for update'就可以了。当前读语义：读到所有已经提交的内容。
3.  幻读的问题
    1.  幻读打破了'where id = 5 for update'语义：幻读导致前后两次该语句结果不同，
        而该语句的语义就是我要锁住这一行，不能有其他的增删改。
    2.  幻读打破了数据与日志的一致性：

4.  如何解决幻读：
    1.  间隙锁登场。
    2.  间隙锁与读锁、写锁的加锁规则——冲突规则
        1.  间隙锁只会阻塞中写锁，不会阻塞读锁和间隙锁
    3.  间隙锁的语义：保持这个间隙，不允许插入
    4.  间隙锁与死锁demo1：--下一篇还有一个demo
        1.  db读写场景：多线程下，查询一行，不存在就插入该行；
        2.  死锁描述： 
            ```
            T1:s1(where id = 9 for update)  //加间隙锁 (5,10)
            T2:s2(where id = 9 for update)  //加间隙锁 (5,10)
            T3:s2(insert into t value id = 9)  //insert失败，被s1的间隙锁阻塞
            T4:s1(insert into t value id = 9)  //insert失败，被s2的间隙锁阻塞
            ```
        3.  死锁会被死锁检查到
    5.  间隙锁与'next-key锁'互相勾结-死锁 demo2：
        1.  db操作描述：多线程下，后者被锁在next-key锁的行锁上，
            同时持有间隙锁，导致前者再在间隙内的插入被后者阻塞，形成死锁
        2.  死锁场景： 
            ```
            T1: s1(where c = 10 lock in share mode) //加(5,10] next-key lock
            T2: s2(insert .. (10, 10))      // 加了(5,10), 被s1的10的行锁阻塞
            T3: s1(insert .. (8, 8))        // 被s2的(5,10)间隙锁阻塞
            ```

5.  幻读-间隙锁-隔离级别
    1.  为了少点加锁消耗，就用rc吧，同时幻读现象也就存在了
    2.  既然rc了，还是尽量消除幻读的第二个问题：数据与日志不一致，所以binlog的格式
        就只能选择row了。

6.  