# 1.常用命令


# 2.主要知识点

1.  一个完整的客户端请求-服务端响应-客户端获取到数据的过程
    1.  客户端连接：客户端发出connect命令，服务端就会产生一个Acceptable文件事件
        1.  acceptable文件事件处理器会将该'命令执行处理器'关联到readable文件事件
    2.  客户端发送命令：客户端write了某些命令，服务端就会有一个Readable文件事件
        1.  '命令请求处理器'执行命令，然后把'命令回复处理器'与writable事件关联
    3.  当客户端读取数据：客户端读取步骤2所发送的命令的响应时，服务端就会产生一个writable文件事件。
        1.  '命令回复处理器'负责将命令回复内容返回给客户端，并取消'命令回复处理器'与该socket的writable事件'的关联

    4.  存疑点：命令的执行和关联'命令回复处理器'到socket的writable事件之前'，客户端的尝试获取数据到来了呢，
        即socket的writable事件早于'关联'呢？
        回答：这只是一个细节实现而已，这里也包含着客户端如何和服务端交互。
            1.  全部都是由客户端主动吗？比如客户端主动发命令请求到服务端。
                服务端执行命令，并把结果放到一个地方。客户端再来读取命令结果——
                服务端这时才把数据发给客户端(如果客户端不来取，服务端不会主动发数据给客户端)。
            2.  在一种情况就是，客户端发起命令，然后，服务端执行，执行好之后，服务端主动发命令结果
                该客户端。

    5.  补充：这里没有深入服务端是如何处理一个命令请求的（第14章 服务器）
        1.  查找命令表（命令不区分大小写）
        2.  执行预备操作
            1.  总的来讲就是根据服务器所处状态、当前会话状态，来判断当前命令是否可以执行
            2.  比如：如果客户端正在执行事务，那么服务器只能执行客户端发来的exec、discard、multi、watch命令
            3.  如果服务器上次BGSAVE命令出错，而当前命令是一个写命令，则服务器拒绝执行该命令，并返回错误
        3.  调用命令的实现函数
            
        4.  命令的后续操作
            1.  记录慢查询
            2.  更新redisCommand结构的执行总时间、调用次数
            3.  如果开启了aof，则写该命令到aof缓冲
            4.  如果有其他复制服务器，则传播该命令
        5.  发送命令回复给客户端
            1.  这里我们有个存疑点：
                1.  把命令回复写在'输出缓冲区'中，然后关联客户端的socket的writable事件到'命令回复处理器'。
                2.  等到客户端是'可写状态'后，就直接发送给客户端
                3.  我们的存疑点是：
                    如果客户端的'可写状态'早于命令回复呢?这个状态肯定不能丢，所以执行阻塞
            
2.  定时事件和周期事件的实现
    1.  很简单：看时间处理器的返回值，如果是指定的定时时间常量，那么就是定时时间；
        如果是一个long，该long就是下次执行这个周期时间的德尔塔时间戳。
    2.  时间事件用一个无序链表组织
    3.  时间时间可以取消，当然有api了
    4.  当前redis之后一个周期时间——serverCron。

3.  serverCron中的逻辑模块
    第一个版本：第14章
        1.  更新服务器的时间缓存
        2.  更新LRU时钟
        3.  更新服务器每秒执行命令次数
        4.  更新服务器内存峰值记录
        5.  处理sigTerm信号——扩展：系统的kill命令
        6.  管理客户端资源
        7.  管理数据库资源
        8.  执行被（BGSAVE命令）延迟的BGREWRITEAOF命令
        9.  检查持久化操作的运行状态——比如切换aof文件/rdb文件
        10. 将aof缓冲区内容同步到文件
        11. 关闭异步客户端：看13章
        12. 增长cronLoop计数器的值 
    第二个版本：来自第12章-事件
        1.  更新服务器的各种统计信息-info命令
        2.  清理服务器中过期的key
            1.  周期删除策略：函数
        3.  关闭和清理链接失效的客户端
        4.  尝试进行aof或者rdb持久化操作——
            1.  bgsave选项是否满足，满足就要执行rdb
            2.  重新aof的条件是否满足，满足了就要重写aof了
        5.  如果服务器是主服务器，对从服务器进行定期同步
        6.  如果处于集群模式，对进群进行定期同步和链接测试
    
4.  Redis服务器的主函数
    1.  init-server
    2.  while(服务器没有关闭){
            (时间/文件)事件处理
            1.  时间时间和文件时间的交织？
        }  
    3.  clean server
    
5.  文件事件、时间事件、serverCron函数，eventLoop是如何组织在一起的
    1.  总体就像4.Redis服务器的主函数
    2.  while内主要就是执行aeProcessEvents():
        1.  在'时间事件链'上找到一个时间事件——目前就一个serverCron，是在服务器初始化的时候添加上去的
        2.  执行该时间事件或者第一个文件事件
    3.  条件"服务器没有关闭"，来自于serverCron中对signTerm信号处理的逻辑：
        1.  先做一些收尾工作（这些收尾工作当然也可以在clean server阶段做）
        2.  把'服务器关闭'标志标记成true


  
    
# 3.扩展
1.  多虑复用技术
    1.  epoll
    2.  kqueue
    3.  select

2.  服务器的统计信息可以用info命令查看