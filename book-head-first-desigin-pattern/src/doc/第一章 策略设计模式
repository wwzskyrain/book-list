# 1.策略设计模式
1.  鸭子模型
2.  情景一：当前已经有了一个鸭子类簇，具体有MallardDuck和RedHeadDuck和TangLaoDuck等其他鸭子，当然还有他们的父类Duck；
    这是需要给鸭子添加一个fly行为；

# 2.实现
## 2.1  实现一——继承：
    在Duck中添加fly()方法，并且实现它，这样子类都有了fly行为了；当子类需要定制的鸭子行为的时候，可以'覆盖它'
1.  优点：达到了代码复用的目的；
2.  缺点：复用不够灵活。比如，如果子类Sub1和Sub2是直接继承父类Duck的实现FlyImpA，
    Sub3、Sub4、Sub5却都要以FlyImpB来实现，则那么我们FlyImplB就要出现三次了。
    所以当前的矛盾是，不适用父类的实现的行为大量存在，而没法复用
    

## 2.2  实现二——接口 
1.  具体实现：接口——把fly行为抽象成接口，让每个duck都实现fly
2.  缺点：很明显，重复实现代码的现象依然存在。
        因为接口只能声明行为，而不能定义行为、更不能被引用。

## 2.3代码重复的危害：修改时需要全部副本修改
    解决：代码只有一处，对其使用可以多处；
    细化：这一处代码写在哪里？如何引用它？首先引用它的地方是哪些实现类。如何引用呢？用"委托+多态"的形式呀。
        那么代码定义在哪里
        
1.  到这里问题几乎就解决了，下面是对'细化'解决方案的补充
    1.  抽离出各种飞行行为，抽离成一个接口fly；
    2.  针对fly接口，编写各种实现，比如'火箭动力飞行'、'贴着地面飞行'等
    3.  在父类Duck中声明fly成员变量，作为被委托者。
        注意：Duck中依然有performFly的方法，因为用户就是针对Duck这个抽象编程的，不是针对fly接口来编程哟！
    4.  在Duck的各个实现中，赋值fly的某一个实现给fly成员变量，并且在performFly中简单的通过委托来实现。
    5.  在运行时，当要改变某个子类的performFly行为，只需要再set一个想要的fly的实现即可。

2.  如何实现策略模式：委托+多态
3.  委托是运用'组合'设计原则的最好的例子
    

# 3.设计原则
1.  【变和不变的分家】把变化的和不变的区分出来。会变化的如何处理，不变化的如何处理？
    有时候，这个界限很难划清楚，所以在设计之初，尽量把会变化的范围往大了去设计
2.  【针对抽象编程而不是实现】注意它的另一种不准确的说法——面向接口编程；其错误点是'接口'，
    这个词被复用的太多。

3.  变化的，属于实现部分；要用不变的抽象去引用他们。不变的还有一部分，那就是当前不变，当这部分也需要变化的时候，
    就也要服从'变化的，属于实现部分；要用不变的抽象去引用他们'；

4.  多用组合，少用继承。

# 4.主题：策略设计模式
1.  定义：定义了算法簇，分别封装起来，让它们之间可以相互替换。此模式让算法的变化独立于算法的用户。