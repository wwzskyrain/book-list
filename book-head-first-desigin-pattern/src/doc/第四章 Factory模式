#   1.Factory模式
1.  有三个所谓的Factory模式：简单Factory、Factory方法、抽象Factory
2.  名词解释-工厂方法模式：定义了一个创建对象的接口，单有子类决定实例化的类是哪一个。工厂方法让类把实例化推迟到子类中。
3.  名词解释-抽象工厂：提供了一个接口，用于创建相关的家族，而不需要指定具体的类。（有一个言不达意的定义）
4.  涉及的原则：依赖倒置和开闭原则和封装变化

# 2.简单工厂
2.  辨析变与不变，然后把变化的部分封装起来：在PizzaStore披萨商店中，接收各种类型的披萨订单并输出该披萨。其中第一部分：各种类型的披萨是变化的，有'芝士披萨'、
    '辣椒披萨'、'哈利披萨'等，而第二部分是：准备、烘烤、切片、装箱，这四步是不变的，
    所以要把第一部分封装到一个Factory类中。这就是"简单工厂"——根据参数返回不同类型的Pizza。
    
3.  "简单工厂的实现"：用一个if-else就+new来实现Factory，然后在用户PizzaStore中持有一个SimpleFactory的引用(组合)。
4.  简单工厂可以用静态方法来实现，这时候也叫做静态工厂。

# 3.工厂方法
1.  现在要开加盟店：纽约的披萨店、芝加哥的披萨店、费城的披萨店。而每个地方的披萨店都需要生产当地风味的披萨。
2.  这时候就有了三簇披萨，分别是纽约风味的'芝士披萨'、'辣椒披萨'、'哈利披萨'；芝加哥风味的'芝士披萨'、'辣椒披萨'、'哈利披萨'；费城风味的'芝士披萨'、'辣椒披萨'、'哈利披萨'。
3.  这时候，需要在三个地方修建工厂，分别是纽约披萨工厂、芝加哥披萨工厂、费城披萨工厂。每个工厂负责相应风味的三种披萨的生产。
4.  三家加盟店分别用对应的披萨工厂来生成'披萨'
5.  工厂方法介绍完毕，总结一下：
    1.  现在有三簇披萨了
    2.  有三个工程：每簇披萨有一个对应的工厂来生成，每个工厂都是一个简单factory
    3.  有三个披萨店：每个披萨店都是面向超累Pizza和PizzaFactory来编程
    4.  最后，用户决定去哪一家披萨店就餐披萨
    5.  一句话：工厂方法是简单工厂的垂直扩展——(类型*风味)
6.  假设没有工厂方法，也没有简单工厂
    1.  则PizzaStory会依赖所有风味的所有种类的Pizza，当有新风味、新类型的披萨加入时，就要修改这个PizzaStory
    2.  有了工厂方法和简单工厂后，PizzaStore只需要面向Pizza和Factory这两个抽象类就可以了。而且PizzaStore也能水平扩展
    3.  这就是依赖倒置，或者说面向抽象编程，而不是面向具体编程


# 4.抽象工厂
1.  在工厂方法的基础上，如果我们要创建的不是一个Product——这里就是pizza，而是一组Product——书中是pizza的各种原料(辣椒、哈利、芝士)，那这里就变成了抽象工厂了
2.  特点：
    1.  抽象Factory中定义了一组创建各种原料的接口，比如辣椒、哈利、芝士、面团等。相应也就有四个基类了
    2.  子类Factory实现各地风味的原料生产实现。
    3.  抽象方法是简单工厂的水平扩展，把类型换成了多个并列的产品

3.  抽象工厂和工厂方法
    1.  我觉得二者是合作的关系。各地的披萨工厂应该从各地的披萨原料工厂进货，来生成不同风味的各种类型的披萨。

# 5.为什么有工厂方法还有抽象方法
1.  都是为了代码的扩展和维护来写的，这样有利于代码的局部维护，只有功能模块良好的代码才能更容易维护、出错更少。  

